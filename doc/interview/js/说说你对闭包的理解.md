# 闭包（Closure）详解

闭包是函数和其周围状态（词法环境）的组合，可以简单理解为“函数记住了自己被创建时的环境”。

## 举个直观的例子
function outer() {
  const name = "Alice"; // outer 函数的局部变量

  function inner() {
    console.log(name); // inner 函数访问 outer 的变量
  }

  return inner; // 返回 inner 函数
}

const myFunc = outer(); // outer 执行完毕，按理说 name 应该被销毁
myFunc(); // 输出 "Alice" ✅——闭包让 inner 记住了 name 的值！

## 闭包的经典应用场景

### 1. 模块化开发（封装私有变量）
function createCounter() {
  let count = 0; // 私有变量，外部无法直接访问

  return {
    increment: () => { count++; },
    getCount: () => { return count; }
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.getCount()); // 1
**优势**：count 被保护在闭包内，只能通过暴露的方法修改，避免全局污染。

### 2. 回调函数（保留上下文）
function fetchData(url) {
  let data = null;

  // 模拟异步请求
  setTimeout(() => {
    data = "响应数据";
  }, 1000);

  return { 
    then: (callback) => { 
      setTimeout(() => {
        callback(data); // 回调函数通过闭包访问 data
      }, 1000);
    }
  };
}

fetchData("https://api.example.com")
  .then((data) => console.log(data)); // 1秒后输出 "响应数据"// 记住你的偏好（比如网页主题）
function 主题切换器(初始主题) {
  let 当前主题 = 初始主题; // 藏在闭包里的主题

  return {
    切换主题: () => {
      当前主题 = 当前主题 === 'light' ? 'dark' : 'light';
      document.body.style.background = 当前主题 === 'dark' ? '#333' : '#fff';
    }
  };
}

const 切换按钮 = 主题切换器('light');
document.getElementById('themeBtn').addEventListener('click', 切换按钮.切换主题);
**闭包的作用**：点击按钮时，函数依然记得 当前主题 的值（即使函数已经执行完），实现状态持久化。