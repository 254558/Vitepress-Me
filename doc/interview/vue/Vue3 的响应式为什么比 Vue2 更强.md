# Vue2 与 Vue3 响应式系统对比

## Vue2 的响应式局限

Vue2 的响应式系统基于 `Object.defineProperty()` 实现，虽然能监听对象属性的访问和修改，但存在不少问题：

- 新增或删除属性时，无法自动触发视图更新，必须用 `Vue.set` 或 `this.$set` 手动处理；
- 对数组的监听不完整，比如直接通过索引赋值（如 `arr[0] = 1`）或修改 `length` 时，Vue2 感知不到；
- 只能监听对象的最外层属性，嵌套对象需要一层层递归处理，每层都要手动设置 getter/setter，数据层级深时性能会明显下降；
- 仅支持普通对象，无法监听 Map、Set、WeakMap 等特殊数据结构。


## Vue3 的响应式系统改进

Vue3 基于 ES6 的 Proxy 重写了响应式系统，从根本上解决了 Vue2 的缺陷。其核心逻辑是：

- 读取数据时（get），通过 `track` 方法追踪数据依赖；
- 修改数据时（set），通过 `trigger` 方法触发相关逻辑更新；
- 结合 `Reflect` 优化 Proxy 的使用体验。

Vue3 不再针对单个属性做劫持，而是直接代理整个对象。这使得它甚至能监听 Map 的 `set` 方法、Set 的 `add` 方法等操作——这些都是 Vue2 完全做不到的。


## Vue2 与 Vue3 响应式设计对比表

| 对比维度       | Vue2 实现                          | Vue3 实现                        |
|----------------|-----------------------------------|---------------------------------|
| 实现方式       | `Object.defineProperty`           | `Proxy`                         |
| 监听粒度       | 针对每个属性单独监听               | 代理整个对象                     |
| 动态属性支持   | 不支持（需手动调用 `Vue.set`）     | 原生支持动态增删属性             |
| 数组监听       | 部分操作（如索引赋值）无法监听     | 所有数组操作均可被监听           |
| 数据结构支持   | 仅支持普通对象                     | 支持 Map、Set、WeakMap 等结构    |
| 嵌套监听方式   | 初始化时递归遍历所有层级           | 懒监听（用到时才处理），性能更优 |
| 响应式逻辑解耦 | 响应逻辑与组件内部代码耦合         | 通过 Effect 模块集中处理         |